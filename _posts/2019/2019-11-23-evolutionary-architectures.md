---
layout: article
title:  演进式陷阱与反模式
---

内容来自阅读《演进式架构》

## 供应商为王

与其沦为供应商为王反模式的受害者，我们不如将供应商产品视为集成点，开发人员可以在集成点间构建防腐层，从而避免架构受到供应商工具变更的影响

## 抽象泄露

抽象是有代价的，因为没有抽象是完美的，如果有，那么它将不再是抽象，而是实际存在，所有重大抽象机制都会泄露，抽象往往会出现意外偏差

```
始终保持对当下抽象层以下至少一个抽象层的完全理解
了解复杂技术栈的脆弱部分
```

越来越复杂的现代软件

![](/images/modern-soft.png)

## 最后10%

所有项目都存在缺憾，80%部分好解决，10%难解决，10%非常复杂


IBM的旧金山项目:
```
架构师和开发人员的终极妄想，他们想凭借自己天生直觉来将一切事物分门别类，但整洁的解决方案无法解决现实世界汇总一些混乱的事物，例如业务流程
```

```
任何细节之下总是存在另一层更细粒度的细节
```

原文:

![](/images/sanfrancisco.png)



这其实是这个世界多层次复杂性的原因

```
宇宙无限
维度无限
山外有山
天外有天
觉上有觉
佛上有佛
```


## 代码复用和滥用

```
复用软件更像是器官移植而不是拼装乐高积木
```

```
代码复用性越高，其可用性越底
```

当开发人员构建可复用的代码时，他们必然会为了将来开发人员以各种方式使用该代码添加特性，所有针对未来的特性都使得开发人员更难将代码用于单一目的
微服务避免代码复用，遵循重复优于耦合的理念

## 简历驱动开发

```
不要为了架构而构建架构，构建架构是为了解决问题
```
在选择架构前，要始终理解问题域，不要本末倒置


## 管理不当

在现代环境中，将不同技术栈统一成单一技术栈是不当的管理，这会无意将问题过度复杂化，管理决策使得实现解决方案所需的工作毫无意义地成倍增加

## 发布过慢 

良好的工程，部署和发布实践是使演进式架构获得成功的关键，反过来又通过假设驱动开发为业务提供新能力

## 产品定制

功能开关和定制化的存在导致产品具有很多可能的路径排列，显著加重了测试负担，企业应该实事求是地评估相关成本

## 报表

从架构的角度来看，协调也是一种耦合，使用最终一致性能让架构师免于协调，为应用程序的不同用途做出不同抽象
消除因混合和报表引起的不当耦合，使得每个团队可以专注于更加具体且简单的任务

隔离:

![](/images/report.png)


## 规划视野

谨防长期规划，因为他会迫使架构师做出的决策不可逆转，将大型项目分解成更小的早起可交付物，避免沉默成本的误区

